PEP 是 **“Python Enhancement Proposal”** 的缩写，中文通常叫“Python 增强提案”。  
它是一份设计文档，用来向 Python 社区提出：

* 新语言特性  
* 标准库新增/修改  
* 开发流程、编码规范、发布策略等改进  

每份 PEP 先由作者公开草案，经 python-dev 邮件列表充分讨论，最后由 Python Steering Council 决定是否接受。一旦被接受，它就成为官方标准或信息指引，随相应版本的 Python 发布落地 。

下面把“最重要的 PEP”按主题分组，列出发号、名称、引入版本与一句话作用，方便速查。

| 发号 | 名称（关键词） | 引入版本 | 一句话作用 |
|---|---|---|---|
| **语言语法** |
| PEP 8 | Style Guide for Python Code | 2001 | 社区最广泛遵循的代码格式与命名规范 。 |
| PEP 492 | async / await 语法 | 3.5 | 把协程做成一等语法，实现高效 I/O 并发 。 |
| PEP 572 | 海象运算符 := | 3.8 | 在表达式内完成赋值，减少重复求值。 |
| PEP 634 | 结构化模式匹配 (match-case) | 3.10 | 类似 switch，但支持解构与守卫条件。 |
| **类型提示** |
| PEP 484 | Type Hints | 3.5 | 引入函数注解＋ typing 模块，让静态检查成为可能 。 |
| PEP 526 | 变量注解语法 | 3.6 | 给类属性、全局/局部变量也加上类型提示 。 |
| PEP 585 | 内置泛型 (list[int]) | 3.9 | 不再必须从 typing 引入 List Dict 等，减少运行时开销 。 |
| PEP 604 | 联合类型简写 (str \| int) | 3.10 | 用 \| 代替 Union，让类型提示更直观 。 |
| PEP 544 | Protocol（静态“鸭子类型”） | 3.8 | 无需继承即可描述对象接口，提升抽象灵活性 。 |
| **数据与性能** |
| PEP 448 | 更通用解包 | 3.5 | 允许 {**d1, **d2}、[*a, *b] 等写法。 |
| PEP 557 | Data Classes | 3.7 | 用 @dataclass 自动生成 __init__/__repr__ 等样板代码 。 |
| PEP 634-636 | 模式匹配三件套 | 3.10 | 与序列/映射/类解构深度结合，替代冗长 if-elif。 |
| **构建与发布** |
| PEP 440 | 版本号统一规范 | 2013 | 规定 “1.2.3b1” 等格式，pip/PyPI 统一识别。 |
| PEP 508 | 依赖声明语法 | 2016 | pip install_requires 可写 “pkg>=1.0; extra=='dev'” 。 |
| PEP 517/518 | 构建后端隔离 | 3.6+ | 允许用 flit、poetry 等非 setuptools 工具打包。 |
| PEP 561 | 分发类型信息 | 3.7 | 让包作者随 wheel 发布 *.pyi 或 typed 标记。 |
| **C-API & 稳定性** |
| PEP 384 | 稳定 ABI | 3.2 | 定义有限的 “python3.dll” 接口，扩展模块可跨小版本二进制兼容 。 |
| **并发与并行** |
| PEP 3156 | asyncio 框架 | 3.4 | 统一事件循环、传输/协议、Future/Task 模型。 |
| PEP 525/530 | 异步生成器/异步推导式 | 3.6/3.7 | 让 yield 与 for 也能在协程里高效工作 。 |

掌握这些高频 PEP，就能快速理解 Python 近十年新增特性的来龙去脉，以及在代码风格、类型检查、打包发布、异步编程等关键场景里的最佳实践。