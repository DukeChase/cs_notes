# SSM 教程
`WebApplicationInitializer`

[spring cloud alibaba  官方教程SCA](https://sca.aliyun.com/learn/spring/?spm=0.29160081.0.0.3bc47d61E0FwPl)

当一个请求到达基于Java的Spring框架时，它会经历以下几个主要部分：

1. **DispatcherServlet**：这是Spring MVC的核心组件，负责接收所有的HTTP请求并分发给相应的处理器。它充当前端控制器，是整个请求处理流程的起点。
2. **Handler Mapping**：这部分负责根据请求URL找到对应的处理器（Controller）。Spring MVC支持多种Handler Mapping实现，如`BeanNameUrlHandlerMapping`、`SimpleUrlHandlerMapping`等。
3. **Controller**：这是实际处理请求的组件。通常，你会在这里编写业务逻辑，处理用户输入，并与模型（Model）交互。
4. **Model**：模型包含业务数据和业务逻辑。通常，模型数据会存储在数据库中，Controller会从模型中获取或更新数据。
5. **View Resolver**：视图解析器负责解析逻辑视图名称到具体视图实现。例如，当Controller返回一个逻辑视图名称时，`View Resolver`会将其解析为具体的JSP页面、Thymeleaf模板等。
6. **View**：视图负责渲染模型数据，以呈现给用户。在Spring MVC中，可以使用多种视图技术，如`JSP`、`Thymeleaf`、`Freemarker`等。

整个处理流程大致如下：

1. 用户发送HTTP请求到`DispatcherServlet`。
2. `DispatcherServlet`将请求发送给合适的`Handler Mapping`。
3. `Handler Mapping`找到处理该请求的`Controller`。
4. `DispatcherServlet`将请求发送给找到的`Controller`。
5. `Controller`处理请求，与Model交互，并返回一个逻辑视图名称。
6. `DispatcherServlet`将逻辑视图名称发送给`View Resolver`。
7. `View Resolver`解析逻辑视图名称为具体的视图实现。
8. `DispatcherServlet`将模型数据发送给解析后的视图。
9. 视图渲染模型数据，生成响应内容。
10. 视图将响应内容返回给`DispatcherServlet`。
11. `DispatcherServlet`将响应发送给用户。

这个流程涵盖了Spring MVC的主要组件和它们之间的交互。当然，实际的处理过程可能会根据具体的配置和业务需求有所不同。  
**generated by 文心一言**

课程链接：[【尚硅谷】SSM框架全套教程，MyBatis+Spring+SpringMVC+SSM整合一套通关】](https://www.bilibili.com/video/BV1Ya411S7aT/?share_source=copy_web&vd_source=e65574be5c4ff436d099ae0526b97fd9)

# 
# 
# SpringMVC
## 什么是MVC
MVC是一种软件架构的思想，将软件按照**模型、视图、控制器**来划分  
M：Model，模型层，指工程中的JavaBean，作用是处理数据  
JavaBean分为两类：

+ 一类称为实体类Bean：专门存储业务数据的，如 Student、User 等
+ 一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。

V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据  
C：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器

MVC的工作流程： 用户通过**视图层**发送请求到服务器，在服务器中请求被`Controller`接收，`Controller`调用相应的`Model`层处理请求，处理完毕将结果返回到Controller，Controller再根据请求处理的结果找到相应的View视图，渲染数据后最终响应给浏览器。

## 入门案例
web.xml中

+ 注册SpringMVC的前端控制器`DispatcherServlet`
+ 配置SpringMVC的前端控制器  `DispatcherServlet`  
SpringMVC的**配置文件默认的位置和名称**：  
位置：WEB-INF下  
名称：`<servlet-name>-servlet.xml`，当前配置下的配置文件名为`SpringMVC-servlet.xml`  
url-pattern中`/`和`/*`的区别：  
`/`：匹配浏览器向服务器发送的所有请求（不包括.jsp）  
`/*`：匹配浏览器向服务器发送的所有请求（包括.jsp）  
jsp文件由tomcat的JspServlet处理
+ 配置web.xml文件

```xml
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"  
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"  
         version="4.0">  
    <servlet>
        <servlet-name>SpringMVC</servlet-name>  
            <servlet-class>
            org.springframework.web.servlet.DispatcherServlet
            </servlet-class>  
        <!--设置SpringMVC配置文件的位置和名称-->  
        <init-param>  
            <param-name>contextConfigLocation</param-name>  
            <param-value>classpath:springmvc.xml</param-value>  
        </init-param>         
        <!--        
        作为框架的核心组件，在启动过程中有大量的初始化操作要做        
        而这些操作放在第一次请求时才执行会严重影响访问速度        
        因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时
        -->
        <load-on-startup>1</load-on-startup>

    </servlet>

        
    <servlet-mapping>        
        <servlet-name>springMVC</servlet-name>

        <!--    
        设置springMVC的核心控制器所能处理的请求的请求路径
        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径
        但是/不能匹配.jsp请求路径的请求        
        -->
        <url-pattern>/</url-pattern>

    </servlet-mapping>

</web-app>

```

`<url-pattern>`标签中使用`/`和`/*`的区别：  
`/`所匹配的请求可以是`/login`或`.html`或`.js`或`.css`方式的请求路径，但是`/`不能匹配`.jsp`请求路径的请求因此就可以避免在访问jsp页面时，该请求被DispatcherServlet处理，从而找不到相应的页面  
`/*`则能够匹配所有请求，例如在使用**过滤器**时，若需要对所有请求进行过滤，就需要使用`/*`的写法

+ 创建请求控制器  
由于前端控制器对浏览器发送的请求进行了统一的处理，但是具体的请求有不同的处理过程，因此需要创建处理具体请求的类，即_**请求控制器**_  
请求控制器中每一个处理请求的方法成为_**控制器方法**_  
因为SpringMVC的控制器由一个POJO（普通的Java类）担任，因此需要通过`@Controller`注解将其标识为一个_**控制层组件**_，交给Spring的IoC容器管理，此时SpringMVC才能够识别控制器的存在。

```java
@Controller
public class HelloController{

}
```

初始化DispatcherServlet时会读取springMVC配置文件。

+ `SpringMVC`的配置文件

```xml
<!-- 自动扫描包 -->
<context:component-scan base-package="com.atguigu.mvc.controller"/>
<!-- 配置Thymeleaf视图解析器 -->
<bean id="viewResolver"
class="org.thymeleaf.spring5.view.ThymeleafViewResolver">
    <property name="order" value="1"/>
    <property name="characterEncoding" value="UTF-8"/>
    <property name="templateEngine">
    <bean class="org.thymeleaf.spring5.SpringTemplateEngine">
    <property name="templateResolver">
            <bean        class="org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver">
            <!-- 视图前缀 -->
                <property name="prefix" value="/WEB-INF/templates/"/>
                <!-- 视图后缀 -->
                <property name="suffix" value=".html"/>
                <property name="templateMode" value="HTML5"/>
                <property name="characterEncoding" value="UTF-8" />
            </bean>

        </property>

        </bean>

    </property>

</bean>

<!--
处理静态资源，例如html、js、css、jpg
若只设置该标签，则只能访问静态资源，其他请求则无法访问
此时必须设置<mvc:annotation-driven/>解决问题
-->
<mvc:default-servlet-handler/>
<!-- 开启mvc注解驱动 -->
<mvc:annotation-driven>
    <mvc:message-converters>
        <!-- 处理响应中文内容乱码 -->
        <bean
        class="org.springframework.http.converter.StringHttpMessageConverter">
            <property name="defaultCharset" value="UTF-8" />
            <property name="supportedMediaTypes">
                <list>
                    <value>text/html</value>

                    <value>application/json</value>

                </list>

            </property>

        </bean>

    </mvc:message-converters>

</mvc:annotation-driven>

```

## 案例总结
浏览器发送请求，若请求地址符合前端控制器的`url-pattern`，该请求就会被前端控制器`DispatcherServlet`处理。  
**前端控制器会读取SpringMVC的核心配置文件**，通过扫描组件找到控制器，将请求地址和控制器中`@RequestMapping`注解的`value`属性值进行匹配，若匹配成功，该注解所标识的控制器方法就是处理请求的方法。  
处理请求的方法需要返回一个字符串类型的视图名称，该视图名称会被_**视图解析器**_解析，加上前缀和后缀组成视图的路径，通过`Thymeleaf`对视图进行渲染，最终转发到视图所对应页面

## @RequestMapping注解
1. `@RequestMapping`注解标识的位置  
    - `@RequestMapping`标识一个类：设置映射请求的请求路径的初始信息  
    - `@RequestMapping`标识一个方法：设置映射请求请求路径的具体信息
2. `@RequestMapping`注解value属性  
    - 作用：通过请求的请求路径匹配请求  
    - `value`属性是数组类型，即当前浏览器所发送请求的请求路径匹配`value`属性中的任何一个值 ，则当前请求就会被注解所标识的方法进行处理
3. `@RequestMapping`注解的`method`属性  
    - 作用：通过请求的请求方式匹配请求  
    - `method`属性是`RequestMethod`类型的数组，即当前浏览器所发送请求的请求方式匹配`method`属性中的任何一中请求方式  
    - 则当前请求就会被注解所标识的方法进行处理  
    - 若浏览器所发送的请求的请求路径和`@RequestMapping`注解`value`属性匹配，但是请求方式不匹配，此时页面报错：`405 - Request method 'xxx' not supported`
    - 在@RequestMapping的基础上，结合请求方式的一些派生注解：  
    - `@GetMapping,@PostMapping,@DeleteMapping,@PutMapping`
4. `@RequestMapping`注解的`params`属性  
    - 作用：通过请求的请求参数匹配请求，即浏览器发送的请求的请求参数必须满足params属性的设置  
    - `params`可以使用四种表达式：  
    - `"param"`：表示当前所匹配请求的请求参数中必须携带param参数  
    - `"!param"`：表示当前所匹配请求的请求参数中一定不能携带param参数  
    - `"param=value"`：表示当前所匹配请求的请求参数中必须携带param参数且值必须为value  
    - `"param!=value"`：表示当前所匹配请求的请求参数中可以不携带param，若携带值一定不能是value  
    - 若浏览器所发送的请求的请求路径和@RequestMapping注解value属性匹配，但是请求参数不匹配  
    - 此时页面报错：`400 - Parameter conditions "username" not met for actual request parameters:`
5. `@RequestMapping`注解的`headers`属性  
    - 作用：通过请求的请求头信息匹配请求，即浏览器发送的请求的请求头信息必须满足headers属性的设置  
    - 若浏览器所发送的请求的请求路径和`@RequestMapping`注解`value`属性匹配，但是请求头信息不匹配  
    - 此时页面报错：404
6. SpringMVC支持ant风格的路径  
    - 在`@RequestMapping`注解的value属性值中设置一些特殊字符  
    - `?`:任意的单个字符（不包括?）  
    - `*`:任意个数的任意字符（不包括?和/）  
    - `**`:任意层数的任意目录，注意使用方式只能**写在双斜线中，前后不能有任何的其他字符
7. @RequestMapping注解使用路径中的占位符  
    - 传统：`/deleteUser?id=1`  
    - rest：`/user/delete/1`
    - 需要在`@RequestMapping`注解的value属性中所设置的路径中，使用`{xxx}`的方式表示路径中的数据  
    - 在通过`@PathVariable`注解，将占位符所标识的值和控制器方法的形参进行绑定

## SpringMVC获取请求参数
1. 通过servletAPI获取  
    - 只需要在控制器方法的形参位置设置`HttpServletRequest`类型的形参  
    - 就可以在控制器方法中使用`request`对象获取请求参数
2. 通过控制器方法的形参获取  
    - 只需要在控制器方法的形参位置，设置一个形参，形参的名字和请求参数的名字一致即可
3. `@RequestParam`：将请求参数和控制器方法的形参绑定  
    - `@RequestParam`注解的三个属性：`value、required、defaultValue`
    - `value`:设置和形参绑定的请求参数的名字  
    - `required`:设置是否必须传输value所对应的请求参数  
    - 默认值为true，表示value所对应的请求参数必须传输，否则页面报错：  
    - 400 - Required String parameter 'xxx' is not present  
    - 若设置为false，则表示value所对应的请求参数不是必须传输，若为传输，则形参值为null  
    - `defaultValue`:设置当没有传输value所对应的请求参数时，为形参设置的默认值，此时和required属性值无关
4. `@RequestHeader`：将请求头信息和控制器方法的形参绑定  
5. `@CookieValue`：将cookie数据和控制器方法的形参绑定  
6. 通过控制器方法的实体类类型的形参获取请求参数  
    - 需要在控制器方法的形参位置设置实体类类型的形参，要保证实体类中的属性的属性名和请求参数的名字一致  
    - 可以通过实体类类型的形参获取请求参数
7. 解决获取请求此参数的乱码问题
    - 在`web.xml`中配置Spring的编码过滤器`org.springframework.web.filter.CharacterEncondingFilter`

`web.xml`文件

```xml
<filter>
    <filter-name>CharacterEncodingFilter</filter-name>

    
    <filterclass>
        org.springframework.web.filter.CharacterEncodingFilter
    </filter-class>

    <init-param>
        <param-name>encoding</param-name>

        <param-value>UTF-8</param-value>

    </init-param>

    <init-param>
        <param-name>forceEncoding</param-name>

        <param-value>true</param-value>

    </init-param>

</filter>

<filter-mapping>
    <filter-name>CharacterEncodingFilter</filter-name>

    <url-pattern>/*</url-pattern>

</filter-mapping>

```

## 域对象共享数据
+ 向域对象共享数据：
1. 使用ServletAPI向request域对象共享数据
2. 通过`ModelAndView`向请求域共享数据  
    - 使用`ModelAndView`时，可以使用其Model功能向请求域共享数据  
    - 使用View功能设置逻辑视图，但是控制器方法一定要将`ModelAndView`作为方法的返回值
3. 使用`Model`向请求域共享数据  
4. 使用`ModelMap`向请求域共享数据  
5. 使用`map`向请求域共享数据  
6. `Model`和`ModelMap`和`map`的关系  
    - 其实在底层中，这些类型的形参最终都是通过`BindingAwareModelMap`创建  
    - `public class BindingAwareModelMap extends ExtendedModelMap {}`
    - `public class ExtendedModelMap extends ModelMap implements Model {}`  
    - `public class ModelMap extends LinkedHashMap<String, Object> {}`
+ 向`session`域共享数据

```java
@RequestMapping("/testSession")
public String testSession(HttpSession session){
    session.setAttribute("testSessionScope", "hello,session");
    return "success";
}
```

+ 向`application`域共享数据

```java
@RequestMapping("/testApplication")
public String testApplication(HttpSession session){
    ServletContext application = session.getServletContext();
    application.setAttribute("testApplicationScope", "hello,application");
    return "success";
}
```

## springMVC的视图
SpringMVC中的视图是View接口，视图的作用渲染数据，将模型Model中的数据展示给用户  
当工程引入jstl的依赖，转发视图会自动转换为JstlView  
若使用的视图技术为`Thymeleaf`，在SpringMVC的配置文件中配置了`Thymeleaf`的视图解析器，由此视 图解析器解析之后所得到的是`ThymeleafView`

`thymeleafView`

`InternalResourceViewResolver`   视图解析器

`RedirectView`

## RESTFUL
REST：`Representational State Transfer`，表现层资源状态转移。

SpringMVC 提供了 `HiddenHttpMethodFilter` 帮助我们将 POST 请求转换为 DELETE 或 PUT 请求

`HiddenHttpMethodFilter` 处理put和delete请求的条件：

1. 当前请求的请求方式必须为`post`
2. 当前请求必须传输请求参数`_method`

满足以上条件，`HiddenHttpMethodFilter` 过滤器就会将当前请求的请求方式转换为  
请求参数`_method`的值，因此请求参数`_method`的值才是最终的请求方式

在web.xml中注册`HiddenHttpMethodFilter`

```xml
<filter>  
    <filter-name>CharacterEncodingFilter</filter-name>  
    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>  
    <init-param>        
        <param-name>encoding</param-name>  
        <param-value>UTF-8</param-value>  
    </init-param>    
    <init-param>        
        <param-name>forceEncoding</param-name>  
        <param-value>true</param-value>  
    </init-param>

</filter>  
<filter-mapping>  
    <filter-name>CharacterEncodingFilter</filter-name>  
    <url-pattern>/*</url-pattern>  
</filter-mapping>

```

在web.xml中注册时，必须先注册`CharacterEncodingFilter`，再注册`HiddenHttpMethodFilter`  
原因：  
在 CharacterEncodingFilter 中通过 `request.setCharacterEncoding(encoding)`方法设置字  
符集的`request.setCharacterEncoding(encoding)` 方法要求前面不能有任何获取请求参数的操作  
而 HiddenHttpMethodFilter 恰恰有一个获取请求方式的操作：  
`String paramValue = request.getParameter(this.methodParam);`

一个典型的ssm web应用配置的web.xml文件如下  
包括_**编码过滤器，请求方式过滤器，前端控制器**_

```xml
<!--设置Spring的编码过滤器-->  
<filter>  
    <filter-name>CharacterEncodingFilter</filter-name>  
    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>  
    <init-param>        <param-name>encoding</param-name>  
        <param-value>UTF-8</param-value>  
    </init-param>    <init-param>        <param-name>forceEncoding</param-name>  
        <param-value>true</param-value>  
    </init-param></filter>  
<filter-mapping>  
    <filter-name>CharacterEncodingFilter</filter-name>  
    <url-pattern>/*</url-pattern>  
</filter-mapping>  
  
<!--设置处理请求方式的过滤器-->  
<filter>  
    <filter-name>HiddenHttpMethodFilter</filter-name>  
    <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>  
</filter>  
<filter-mapping>  
    <filter-name>HiddenHttpMethodFilter</filter-name>  
    <url-pattern>/*</url-pattern>  
</filter-mapping>  
  
<!--设置SpringMVC的前端控制器-->  
<servlet>  
    <servlet-name>SpringMVC</servlet-name>  
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>  
    <init-param>        <param-name>contextConfigLocation</param-name>  
        <param-value>classpath:springmvc.xml</param-value>  
    </init-param>    <load-on-startup>1</load-on-startup>  
</servlet>  
<servlet-mapping>  
    <servlet-name>SpringMVC</servlet-name>  
    <url-pattern>/</url-pattern>  
</servlet-mapping>

```

## RESTFUL案例
## 9. SpringMVC处理ajax请求
+ `@RequestBody`
+ `@ResponseBody`

`@ResponseBody`用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器

+ 9.5、`@RestController`注解

`@RestController`注解是springMVC提供的一个复合注解，标识在控制器的类上，就相当于为类添加了`@Controller`注解，并且为其中的每个方法添加了`@ResponseBody`注解

## 10 文件上传和下载
+ `ResponseEntity`用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文使用ResponseEntity实现下载文件的功能
+ `MultipartFile`  文件上传要求`form`表单的请求方式必须为`post`，并且添加属性`enctype="multipart/form-data"`  
SpringMVC中将上传的文件封装到MultipartFile对象中，通过此对象可以获取文件相关信息
1. 添加依赖

```xml
<!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload -->    
<dependency>
<groupId>commons-fileupload</groupId>

<artifactId>commons-fileupload</artifactId>

<version>1.3.1</version>

</dependency>

```

2. 在SpringMVC配置文件中添加配置

```xml
<!--必须通过文件解析器的解析才能将文件转换为MultipartFile对象-->
<bean id="multipartResolver"
class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
</bean>

```

3. 编写控制器方法

```java

/**  
 * Date:2022/7/9 
 * Author:ybc 
 * Description: 
 * ResponseEntity:可以作为控制器方法的返回值，表示响应到浏览器的完整的响应报文  
 *  
 * 文件上传的要求：  
 * 1、form表单的请求方式必须为post  
 * 2、form表单必须设置属性enctype="multipart/form-data"  
 */
 @Controller  
public class FileUpAndDownController {  
  
    @RequestMapping("/test/up")  //上传
    public String testUp(MultipartFile photo, HttpSession session) throws IOException {  
        //获取上传的文件的文件名  
        String fileName = photo.getOriginalFilename();  
        //获取上传的文件的后缀名  
        String hzName = fileName.substring(fileName.lastIndexOf("."));  
        //获取uuid  
        String uuid = UUID.randomUUID().toString();  
        //拼接一个新的文件名  
        fileName = uuid + hzName;  
        //获取ServletContext对象  
        ServletContext servletContext = session.getServletContext();  
        //获取当前工程下photo目录的真实路径  
        String photoPath = servletContext.getRealPath("photo");  
        //创建photoPath所对应的File对象  
        File file = new File(photoPath);  
        //判断file所对应目录是否存在  
        if(!file.exists()){  
            file.mkdir();  
        }  
        String finalPath = photoPath + File.separator + fileName;  
        //上传文件  
        photo.transferTo(new File(finalPath));  
        return "success";  
    }  
  
    @RequestMapping("/test/down")  
    public ResponseEntity<byte[]> testResponseEntity(HttpSession session) throws IOException {  
        //获取ServletContext对象  
        ServletContext servletContext = session.getServletContext();  
        //获取服务器中文件的真实路径  
        String realPath = servletContext.getRealPath("img");  
        realPath = realPath + File.separator + "1.jpg";  
        //创建输入流  
        InputStream is = new FileInputStream(realPath);  
        //创建字节数组，is.available()获取输入流所对应文件的字节数  
        byte[] bytes = new byte[is.available()];  
        //将流读到字节数组中  
        is.read(bytes);  
        //创建HttpHeaders对象设置响应头信息  
        MultiValueMap<String, String> headers = new HttpHeaders();  
        //设置要下载方式以及下载文件的名字  
        headers.add("Content-Disposition", "attachment;filename=1.jpg");  
        //设置响应状态码  
        HttpStatus statusCode = HttpStatus.OK;  
        //创建ResponseEntity对象  
        ResponseEntity<byte[]> responseEntity = new ResponseEntity<>(bytes, headers, statusCode);  
        //关闭输入流  
        is.close();  
        return responseEntity;  
    }  
  
}
```

## 11 拦截器
### 拦截器的配置
SpringMVC中的拦截器用于拦截控制器方法的执行

SpringMVC中的拦截器需要实现`HandlerInterceptor`

SpringMVC的拦截器必须在SpringMVC的配置文件中进行配置

```xml
<bean class="com.atguigu.interceptor.FirstInterceptor"></bean>

<ref bean="firstInterceptor"></ref>

<!-- 以上两种配置方式都是对DispatcherServlet所处理的所有的请求进行拦截 -->

<mvc:interceptor>
    <mvc:mapping path="/**"/>
    <mvc:exclude-mapping path="/testRequestEntity"/>
    <ref bean="firstInterceptor"></ref>

</mvc:interceptor>

<!--
以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过
mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求
-->
```

### 拦截器的三个抽象方法
SpringMVC中的拦截器有三个抽象方法：

`preHandle`：控制器方法执行之前执行`preHandle()`，其`boolean`类型的返回值表示是否拦截或放行，返回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法

`postHandle`：控制器方法执行之后执行`postHandle()`

`afterCompletion`：处理完视图和模型数据，渲染视图完毕之后执行`afterCompletion()`

### 多个拦截器执行顺序
①若每个拦截器的preHandle()都返回true  
此时多个拦截器的执行顺序和拦截器在SpringMVC的配置文件的配置顺序有关：  
`preHandle()`会按照配置的顺序执行，而`postHandle()`和`afterCompletion()`会按照配置的反序执行

②若某个拦截器的preHandle()返回了false  
`preHandle()`返回false和它之前的拦截器的`preHandle()`都会执行，`postHandle()`都不执行，返回false的拦截器之前的拦截器的afterCompletion()会执行

## 12 异常处理器
SpringMVC提供了一个处理控制器方法执行过程中所出现的异常的接口：`HandlerExceptionResolver`

`HandlerExceptionResolver`接口的实现类有：`DefaultHandlerExceptionResolver`和

`SimpleMappingExceptionResolver`

`SpringMVC`提供了自定义的异常处理器`SimpleMappingExceptionResolver`，使用方式：

## 13 注解配置springMVC
## 14 springMVC 执行流程
### 14.1、SpringMVC常用组件
+ `DispatcherServlet`：前端控制器，不需要工程师开发，由框架提供  
作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求
+ `HandlerMapping`：处理器映射器，不需要工程师开发，由框架提供  
作用：根据请求的url、method等信息查找Handler，即控制器方法
+ `Handler`：处理器，需要工程师开发  
作用：在DispatcherServlet的控制下Handler对具体的用户请求进行处理
+ `HandlerAdapter`：处理器适配器，不需要工程师开发，由框架提供  
作用：通过HandlerAdapter对处理器（控制器方法）进行执行
+ `ViewResolver`：视图解析器，不需要工程师开发，由框架提供  
作用：进行视图解析，得到相应的视图，例如：`ThymeleafView、InternalResourceView、RedirectView`
+ `View`：视图  
作用：将模型数据通过页面展示给用户

### 14.2、DispatcherServlet初始化过程
P174     [https://www.bilibili.com/video/BV1Ya411S7aT/?p=174](https://www.bilibili.com/video/BV1Ya411S7aT/?p=174)  
javax.servlet.Servlet

`DispatcherServlet` 本质上是一个`Servlet`，所以天然的遵循 `Servlet` 的生命周期。所以宏观上是 Servlet生命周期来进行调度。(从`javax.servlet.Servlet`的`init`方法开始向下看)

1. 初始化`WebApplicationContext`  
所在类：`org.springframework.web.servlet.FrameworkServlet#initWebApplicationContext`  
webApplicationContext   web中的ioc容器
2. 创建`WebApplicationContext`  
所在类：`org.springframework.web.servlet.FrameworkServlet#createWebApplicationContext`
3. DispatcherServlet初始化策略  
`FrameworkServlet`创建`WebApplicationContext`后，刷新容器，调用`onRefresh(wac)`，此方法在`DispatcherServlet`中进行了重写，调用了`initStrategies(context)`方法，初始化策略，即初始化DispatcherServlet的各个组件  
所在类：`org.springframework.web.servlet.DispatcherServlet#initStrategies`

### 14.3、DispatcherServlet调用组件处理请求
p175    [https://www.bilibili.com/video/BV1Ya411S7aT/?p=175](https://www.bilibili.com/video/BV1Ya411S7aT/?p=175)  
同样也是根据Serlet的生命周期去看，从Servlet的service方法开始。

1. `org.springframework.web.servlet.FrameworkServlet#processRequest`
2. `org.springframework.web.servlet.DispatcherServlet#doService`
3. `org.springframework.web.servlet.DispatcherServlet#doDispatch`
4. ``org.springframework.web.servlet.DispatcherServlet#processDispatchResult`

### 14.4、SpringMVC的执行流程
1. 用户向服务器发送请求，请求被`SpringMVC`前端控制器 `DispatcherServlet`捕获。
2. `DispatcherServlet`对请求URL进行解析，得到请求资源标识符（URI），判断请求URI对应的映射：  
 a) 不存在  
 i. 再判断是否配置了`mvc:default-servlet-handler`  
 ii. 如果没配置，则控制台报映射查找不到，客户端展示404错误  
 iii. 如果有配置，则访问目标资源（一般为静态资源，如：JS,CSS,HTML），找不到客户端也会展示404错误  
 b) 存在则执行下面的流程
3. 根据该URI，调用`HandlerMapping`获得该Handler配置的所有相关的对象（包括Handler对象以  
Handler对象对应的拦截器），最后以`HandlerExecutionChain`执行链对象的形式返回。
4. `DispatcherServlet` 根据获得的`Handler`，选择一个合适的`HandlerAdapter`。
5. 如果成功获得`HandlerAdapter`，此时将开始执行拦截器的`preHandler(…)`方法【正向】
6. 提取`Request`中的模型数据，填充`Handler`入参，开始执行`Handler（Controller)`方法，处理请求。  
 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：  
 a) `HttpMessageConveter`： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息  
 b) 数据转换：对请求消息进行数据转换。如`String`转换成`Integer`、`Double`等  
 c) 数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等  
 d) 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到`BindingResult`或`Error`中
7. Handler执行完成后，向`DispatcherServlet` 返回一个`ModelAndView`对象。
8. 此时将开始执行拦截器的`postHandle(...)`方法【逆向】。
9. 根据返回的`ModelAndView`（此时会判断是否存在异常：如果存在异常，则执行`HandlerExceptionResolver`进行异常处理）选择一个适合的ViewResolver进行视图解析，根据Model和View，来渲染视图。
10. 渲染视图完毕执行拦截器的`afterCompletion(…)`方法【逆向】。
11. 将渲染结果返回给客户端

# 
